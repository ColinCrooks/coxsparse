% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{cox_reg_sparse_parallel}
\alias{cox_reg_sparse_parallel}
\title{cox_reg_sparse_parallel}
\usage{
cox_reg_sparse_parallel(
  modeldata,
  obs_in,
  coval_in,
  weights_in,
  timein_in,
  timeout_in,
  Outcomes_in,
  covstart_in,
  covend_in,
  idn_in,
  idstart_in,
  idend_in,
  lambda,
  theta_in,
  MSTEP_MAX_ITER,
  MAX_EPS,
  threadn
)
}
\arguments{
\item{modeldata}{A list in R of vectors within which to retun the model output.
Needs to follow this naming convention of the lists:
\itemize{
\item Beta - double vector of length of covariates to be filled with fitted coefficients.
\item Frailty - double vector of length of frailty terms (e.g. number of unique patients)
to bw filled with the fitted frailty terms on linear predictor scale
(w in xb + Zw). Exponentiate for the relative scale. No centring applied.
\item basehaz - double vector of length of max(timeout) for baseline hazard values
for each unique observed time. calculated with the fitted coefficients and Efron weights.
\item cumhaz - double vector of length of max(timeout) for cumulative hazard values calculated
from the baseline hazard values.
\item ModelSummary - double vector of length 8 to contain individual values:
** loglik - log likelihood of the model without gamma penalty
** lik_correction - gamma correction for the loglikelihood for including frailty terms
** loglik + lik_correction - the total log likelihood of the model
** theta - the value of theta used in the model
** outer_iter - the number of outer iterations performed
** final convergence of inner loop for covariates abs(1-newlk/loglik)
** final convergence of outer loop for theta
** frailty_mean - the mean of the frailty terms so they can be centred log(mean(exp(frailty)))
}}

\item{obs_in}{An integer vector referencing for each covariate value (sorting as coval) the
corresponding unique patient time in the time and outcome vectors. Of the
same length as coval. The maximum value is the length of timein and timeout.}

\item{coval_in}{A double vector of each covariate value sorted first by order
of the covariates then by time then by patient and to be included in model.
Of the same longth as obs_in.
coval_in\link{i} ~ timein_in[obs_in\link{i}], timeout_in[obs_in\link{i}], Outcomes_in[obs_in\link{i}],}

\item{weights_in}{A double vector of weights to be applied to each unique
patient time point. Of the same length as timein, timeout and outcomes.
Sorted by time out, time in, and patient id.}

\item{timein_in}{An integer vector of the start time for each unique patient
time row, so would be the time that a patient's corresponding
covariate value starts. Of the same length as weights, timeout, and outcomes.
Sorted by time out, time in, and patient id}

\item{timeout_in}{An integer vector of the end time for each unique patient
time row, so would be the time that a patient's corresponding outcome
occurs. Of the same length as weights, timein, timeout and outcomes. Sorted by time out, time in, and patient id}

\item{Outcomes_in}{An integer vector of 0 (censored) or 1 (outcome) for the
corresponding unique patient time. Of the same length as timein, timeout and
weights. Sorted by time out, time in, and patient id}

\item{covstart_in}{An integer64 (from package bit64) vector of the start row for each covariate in coval
Uses}

\item{covend_in}{An integer64 (from package bit64) vector of the end row for each covariate in coval}

\item{idn_in}{An integer vector mapping unique patient IDs sorted by ID to the
corresponding row in observations sorted by time out, time in, and patient id
For id = i the corresponding rows in time_in, timeout_in and Outcomes_in
are the rows listed between idn_in[idstart_in\link{i}]:idn_in[idend_in\link{i}]}

\item{idstart_in}{An integer vector of the start row for each unique patient ID in idn_in}

\item{idend_in}{An integer vector of the end row for each unique patient ID in idn_in}

\item{lambda}{Penalty weight to include for ridge regression: -log(sqrt(lambda)) * nvar}

\item{theta_in}{An input starting value for theta or can be set to zero.}

\item{MSTEP_MAX_ITER}{Maximum number of iterations}

\item{MAX_EPS}{Threshold for maximum step change in liklihood for convergence.}

\item{threadn}{Number of threads to be used - caution as will crash if specify more
threads than available memory for copying data for each thread.}
}
\value{
Void: see the model data input list for the output.
}
\description{
Implementation of a Cox proportional hazards model using
a sparse data structure. The model is fitted with cyclical
coordinate descent (after Mittal et al (2013).
OpenMP is used to parallelise the updating of cumulative
values and rcppParallel objects are used to make R objects
threadsafe.
}
\details{
The purpose of this implementation is for fitting a Cox model
to data when coxph from the survival package fails due to
not enough memory to hold the model and data matrices. The
focus is therefore on being memory efficient, which is a
slower algorithm than in coxph, but parallelisation is
possible to offset this. In this situation compiling the
code for the native computer setup would be preferable
to providing a standard package binary for multiple systems.
The Makevars file therefore contains the options for this.

The total number of observations is allowed to exceed the
maximum integer size in R, so the indexing into covariates
needs to use integer64 vectors as defined in the bit64 package,
and uses the functions kindly provided by Dirk Eddelbuettel for
conversion to C++ vectors (https://github.com/eddelbuettel/RcppInt64).
If number of observations and/or ID also exceed the maximum integer size in R
then the other vectors will also need changing to integer64 vectors. But
this has not currently done to save memory where possible.

The data structure is a deconstructed sparse matrix.

A function using the same data structure to calculate profile
confidence intervals with a crude search pattern is provided.
}
