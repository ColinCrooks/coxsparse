% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{cox_reg_sparse_hess}
\alias{cox_reg_sparse_hess}
\title{cox_reg_sparse_hess}
\usage{
cox_reg_sparse_hess(
  obs_in,
  coval_in,
  weights_in,
  timein_in,
  timeout_in,
  Outcomes_in,
  OutcomeTotals_in,
  OutcomeTotalTimes_in,
  cov_in,
  id_in,
  lambda,
  theta_in,
  MSTEP_MAX_ITER,
  MAX_EPS,
  threadn
)
}
\arguments{
\item{obs_in}{An integer vector referencing for each covariate value the
corresponding unique patient time in the time and outcome vectors. Of the
same length as coval. The maximum value is the length of timein and timeout.}

\item{coval_in}{A double vector of each covariate value sorted first by
time then by patient and by order of the covariates to be included in model.
Of the same longth as obs_in.}

\item{weights_in}{A double vector of weights to be applied to each unique
patient time point. Of the same length as timein, timeout and outcomes.}

\item{timein_in}{An integer vector of the start time for each unique patient
time row, so would be the time that a patient's corresponding
covariate value starts. Of the same length as weights, timeout, and outcomes.}

\item{timeout_in}{An integer vector of the end time for each unique patient
time row, so would be the time that a patient's corresponding outcome
occurs. Of the same length as weights, timein, timeout and outcomes.}

\item{Outcomes_in}{An integer vector of 0 (censored) or 1 (outcome) for the
corresponding unique patient time. Of the same length as timein, timeout and
weights}

\item{OutcomeTotals_in}{An integer vector of the total number of outcomes that
occur at each unique time point. Length is the number of unique times in cohort.}

\item{OutcomeTotalTimes_in}{An integer vector of each unique time point that
outcome events are observed in the cohort. Same length as OutcomeTotals.}

\item{cov_in}{An integer vector mapping covariates to the
corresponding covariate value row in coval sorted by time and id}

\item{id_in}{An integer vector mapping unique patient IDs to the
corresponding row in observations sorted by time and id}

\item{lambda}{Penalty weight to include for ridge regression: -log(sqrt(lambda)) * nvar}

\item{theta_in}{An input starting value for theta or can be set to zero.}

\item{MSTEP_MAX_ITER}{Maximum number of iterations}

\item{MAX_EPS}{Threshold for maximum step change in liklihood for convergence.}

\item{threadn}{Number of threads to be used - caution as will crash if specify more
threads than available memory for copying data for each thread.}
}
\value{
A list of:
\itemize{
\item Beta Fitted coefficients
\item BaseHaz Baseline hazard values for each unique observed time
calculated with the fitted coefficients and Efron weights.
\item CumHaz Cumulative values from the baseline hazard values.
\item BaseHazardEntry Baseline hazard expanded and sorted to correspond to each
patient time in the original data provided in timein.
\item CumHazAtEntry Cumulative hazard values expanded and sorted to correspond to each
patient time in the original data provided in timein.
\item CumHazOneYear Cumulative hazard values expanded and sorted to correspond to one
full year each after each patient time in the original data provided in timein.
\item Risk The hazard (exp(xb)) for each  patient time in the original data
provided in timein.
\item Frailty The frailty value for each unique ID group on linear predictor scale
(w in xb + Zw). Exponentiate for the relative scale. No centring applied.
}
}
\description{
Implementation of a Cox proportional hazards model using
a sparse data structure. The model is fitted with cyclical
coordinate descent (after Mittal et al (2013).
OpenMP is used to parallelise the updating of cumulative
values and rcppParallel objects are used to make R objects
threadsafe.
}
\details{
The purpose of this implementation is for fitting a Cox model
to data when coxph from the survival package fails due to
not enough memory to hold the model and data matrices. The
focus is therefore on being memory efficient, which is a
slower algorithm than in coxph, but parallelisation is
possible to offset this. In this situation compiling the
code for the native computer setup would be preferable
to providing a standard package binary for multiple systems.
The Makevars file therefore contains the options for this.

The data structure is a deconstructed sparse matrix.

A function using the same data structure to calculate profile
confidence intervals with a crude search pattern is provided.
}
