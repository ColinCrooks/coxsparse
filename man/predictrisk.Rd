% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/RcppExports.R
\name{predictrisk}
\alias{predictrisk}
\title{predictrisk}
\usage{
predictrisk(
  beta_in,
  obs_in,
  coval_in,
  frailty_in,
  timein_in,
  timeout_in,
  covstart_in,
  covend_in,
  idn_in,
  idstart_in,
  idend_in,
  cumhaz_in,
  threadn
)
}
\arguments{
\item{beta_in}{A double vector of starting values for the coefficients
of length nvar.}

\item{obs_in}{An integer vector referencing for each covariate value (sorting as coval) the
corresponding unique patient time in the time and outcome vectors. Of the
same length as coval. The maximum value is the length of timein and timeout.}

\item{coval_in}{A double vector of each covariate value sorted first by order
of the covariates then by time then by patient and to be included in model.
Of the same longth as obs_in.
\code{coval_in[i] ~ timein_in[obs_in[i]]}, \code{timeout_in[obs_in[i]]}, \code{Outcomes_in[obs_in[i]]},}

\item{frailty_in}{A double vector of frailty estimates for each idsorted by id.}

\item{timein_in}{An integer vector of the start time for each unique patient
time row, so would be the time that a patient's corresponding
covariate value starts. Of the same length as timeout, and outcomes.
Sorted by time out, time in, and patient id}

\item{timeout_in}{An integer vector of the end time for each unique patient
time row, so would be the time that a patient's corresponding outcome
occurs. Only used to find maximum time out for survival prediction.
Of the same length as timein, timeout and outcomes. Sorted by time out, time in, and patient id}

\item{covstart_in}{An integer64 (from package bit64) vector of the start row for each covariate in coval}

\item{covend_in}{An integer64 (from package bit64) vector of the end row for each covariate in coval}

\item{idn_in}{An integer vector mapping unique patient IDs sorted by ID to the
corresponding row in observations sorted by time out, time in, and patient id
For id = i the corresponding rows in time_in, timeout_in and Outcomes_in
are the rows listed between \code{idn_in[idstart_in[i]]:idn_in[idend_in[i]]}}

\item{idstart_in}{An integer vector of the start row for each unique patient ID in idn_in}

\item{idend_in}{An integer vector of the end row for each unique patient ID in idn_in}

\item{threadn}{Number of threads to be used - caution as will crash if specify more
threads than available memory for copying data for each thread.}
}
\value{
Numeric List with linear predictor and predicted survival.
}
\description{
The purpose of this implementation is for fitting a Cox model
to data when coxph from the survival package fails due to
not enough memory to hold the model and data matrices. The
focus is therefore on being memory efficient, which is a
slower algorithm than in coxph, but parallelisation is
possible to offset this. In this situation compiling the
code for the native computer setup would be preferable
to providing a standard package binary for multiple systems.
The Makevars file therefore contains the options for this.
}
\details{
A function using the same data structure to calculate individual level linear predictors
and survival at the observed times in using the fitted model coefficients and baseline hazards

This function recalculates the individual time level linear predictors,
and the survival probability for each person's time point if that covariate
level was unchanged throughout the follow up.

If time varying covariates are included then the linear predictor
for each time point would need to be combined with the incremental
change in cumulative baseline hazard to calculate the cumulative risk.

The total number of observations*covariates is allowed to exceed the
maximum integer size in R, so the indexing into covariates
needs to use integer64 vectors as defined in the bit64 package,
and uses the functions kindly provided by Dirk Eddelbuettel for
conversion to C++ vectors (https://github.com/eddelbuettel/RcppInt64).
If number of observations and/or ID also exceed the maximum integer size in R
then the other vectors will also need changing to integer64 vectors. But
this has not currently done to save memory where possible.

The data structure is a deconstructed sparse matrix.

This uses the same implementation of a Cox proportional hazards model
as cox_reg_sparse_parallel
OpenMP is used to parallelise the updating of cumulative
values and rcppParallel objects are used to make R objects
threadsafe.
}
